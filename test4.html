<!-- 
PURPOSE: To make the game
next steps:
- create and upload dirt and transparent skins to photobucket 
- skin blocks:
- take snapshot of top, bottom, left, right, front, and back of character,
- label each face with Uv coordinates
- find way to make for larger cube
because of the sizing in block js, the length, width, and height of each block is 0.5
(to fix problem of stretched pixels on cube)  
- add block logic
- add array of dirt blocks to stand on 
-->

<!-- for future reference, if want to make the walking or running so the bottom of the 
shoes do not go below the floor, make it so the y posi of the characters takes into account
the current angle that the legs are positioned-->

<!--http://jeromeetienne.github.io/threex/src/threex-->


<script src='http://conrad1451.github.io/Tiny-Gigantium/build.js'></script>
<script src='http://conrad1451.github.io/Tiny-Gigantium/character.js'></script>
<script src='http://conrad1451.github.io/Tiny-Gigantium/block.js'></script>


<!-- include animation -->
<script src='http://conrad1451.github.io/Tiny-Gigantium/animation.js'></script>
<script src='http://conrad1451.github.io/Tiny-Gigantium/animations.js'></script>

<!-- Headmove and bodymove -->
<script src='http://conrad1451.github.io/Tiny-Gigantium/headmove.js'></script>
<script src='http://conrad1451.github.io/Tiny-Gigantium/bodymove.js'></script>

<!--<script src="http://threejs.org/examples/js/libs/stats.min.js"></script>-->



<!-- ================= -->

<!--<body style='margin: 0px; background-color: #bbbbbb; overflow: hidden;'> -->
<body style='margin: 0px; background-color: #99FFFF; overflow: hidden;'>
<!--- <div id="container"></div> -->

<p id="display1">  </p>
<p id="display2">  </p> 
<p id="display3"> </p> 	
<!--    <p id="theDisplay3">1</p> -->


<script>

var globalVarToShow = 0;

var skinSource = 'http://i1205.photobucket.com/albums/bb424/cman_was_here/';
var choices = ['character_zps6kfdlafp.png', 'character2_zps5jd07vwe.png'];




/*
function sq (aNumber) {
aNumber * aNumber;
}	
*/


var loadSkins = false;//false;	

var degrees = Math.PI/180;
var cheese = 0.00;
var xMove = 0;
var yMove = 0;
var zMove = 0;
var xRoll = 0;
var yRoll = 0;
var zRoll = 0;

var xBlockRoll = 0;
var yBlockRoll = 0;
var zBlockRoll = 0;

var xPosi = 0;
var yPosi = 0;
var zPosi = 0;

var xMoverz = 0;
var aGraphP = 16;
var aGraphSqrt = 0.01;
var bGraphSqrt = 0.6;
var xGraphSqrt = 0;

var speedUp = 0;

var speed = 1;

var seconds = 60;

var characterHeight = 33 * (1/32);

var renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

var updateFcts = [];
var scene = new THREE.Scene();

/*
//controls fog
scene.fog = new THREE.FogExp2(0xcccccc, 0.002);
*/

var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 100);
camera.position.y = 0.5;
camera.position.z = 5;
/*
// lights
light = new THREE.DirectionalLight(0xffffff);
light.position.set(1, 1, 1);
scene.add(light);
light = new THREE.DirectionalLight(0x002288);
light.position.set(-1, -1, -1);
scene.add(light);
light = new THREE.AmbientLight(0x222222);
scene.add(light);
// controls fog
renderer.setClearColor(scene.fog.color);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
container = document.getElementById('container');
container.appendChild(renderer.domElement);
*/


var skinner = [skinSource + choices[0], skinSource + choices[1]];

/*
choice 0 - conrad w/ purple shirt, jeans 
choice 1 - conrad w/ green shirt, jeans
*/


//////////////////////////////////////////////////////////////////////////////////
//		load Character							//
//////////////////////////////////////////////////////////////////////////////////


var firstPlayerInput;
var secondPlayerInput;

if(loadSkins)
{
firstPlayerInput = skinner[0];
secondPlayerInput = skinner[1];
}

var character = new THREEx.TinygigantiumChar();//(firstPlayerInput);
var tinyboy = new THREEx.TinygigantiumChar();//(secondPlayerInput);


scene.add(character.root);
scene.add(tinyboy.root);


// init headAnims
var headAnimsC = new THREEx.TinygigantiumCharHeadAnimations(character);
var headAnimsT = new THREEx.TinygigantiumCharHeadAnimations(tinyboy);


var headMovement = [headAnimsC, headAnimsT];

updateFcts.push(function(delta, now) {
headMovement[0].update(delta, now)
headMovement[1].update(delta, now)
})

headAnimsC.start('still');  // headMovement[0].start('still'); /* could also be headMovement*/  
headAnimsT.start('still');  // headMovement[1].start('still'); /* could also be headMovement*/  

var switchHeadValue = function(value) {
headMovement[0].start(value)
headMovement[1].start(value)
}

// init bodyAnims
var bodyAnimsC = new THREEx.TinygigantiumCharBodyAnimations(character);
var bodyAnimsT = new THREEx.TinygigantiumCharBodyAnimations(tinyboy);
var bodyMovement = [bodyAnimsC, bodyAnimsT];

updateFcts.push(function(delta, now) {
bodyMovement[0].update(delta, now)
bodyMovement[1].update(delta, now)
})

var switchBodyValue = function(value) {
bodyMovement[0].start(value)
bodyMovement[1].start(value)
}


character.root.position.x = -0.5;
character.root.position.y = 0;  
character.root.position.z = 0;
character.root.rotation.y = 180 * degrees;  

tinyboy.root.position.x = 0.5;
tinyboy.root.position.y = 0;  
tinyboy.root.position.z = 0;
tinyboy.root.rotation.y = 180 * degrees;



//////////////////////
//	LOAD BLOCK    //
//                  //
//////////////////////

var blockSkin1 = 'http://i1205.photobucket.com/albums/bb424/cman_was_here/blockblue_zpsjrj2oqg6.png';
var blockSkin2 = 'http://i1205.photobucket.com/albums/bb424/cman_was_here/big-block_zps9lpan5st.png';


function addDirtBlock(){
const dirtBlock = new THREEx.TinygigantiumBlock(blockSkin2);

const[x, y] = Array(2).fill().map(  () => THREE.MathUtils.randFloatSpread(50)  );

dirtBlock.positiion.set(x, y, 0);
scene.add(dirtBlock)	
}	

Array(20).fill().forEach(addDirtBlock);

var dirtBlock1 =  new THREEx.TinygigantiumBlock(blockSkin2);
var dirtBlock2 =  new THREEx.TinygigantiumBlock(blockSkin2);
var dirtBlock3 =  new THREEx.TinygigantiumBlock(blockSkin2);
var dirtBlock4 =  new THREEx.TinygigantiumBlock(blockSkin2);
var dirtBlock5 =  new THREEx.TinygigantiumBlock(blockSkin2);
var dirtBlock6 =  new THREEx.TinygigantiumBlock(blockSkin2);
var dirtBlock7 =  new THREEx.TinygigantiumBlock(blockSkin2);
var dirtBlock8 =  new THREEx.TinygigantiumBlock(blockSkin2);  
var dirtBlock9 =  new THREEx.TinygigantiumBlock(blockSkin2);
var dirtBlock10 =  new THREEx.TinygigantiumBlock(blockSkin2);
var dirtBlock11 =  new THREEx.TinygigantiumBlock(blockSkin2);
var dirtBlock12 =  new THREEx.TinygigantiumBlock(blockSkin2);
var dirtBlock13 =  new THREEx.TinygigantiumBlock(blockSkin2);
var dirtBlock14 =  new THREEx.TinygigantiumBlock(blockSkin2);
var dirtBlock15 =  new THREEx.TinygigantiumBlock(blockSkin2);
var dirtBlock16 =  new THREEx.TinygigantiumBlock(blockSkin2); 	  
var dirtBlock17 =  new THREEx.TinygigantiumBlock(blockSkin2);
var dirtBlock18 =  new THREEx.TinygigantiumBlock(blockSkin2);
var dirtBlock19 =  new THREEx.TinygigantiumBlock(blockSkin2);
var dirtBlock20 =  new THREEx.TinygigantiumBlock(blockSkin2);



var landscape = [
dirtBlock1, dirtBlock2, dirtBlock3, dirtBlock4, dirtBlock5, dirtBlock6, dirtBlock7, dirtBlock8
];

// want to able to automatically append the .root.position for x, y, and z for each new block that is added
var positioning = [
[dirtBlock1.root.position.x, dirtBlock2.root.position.x, dirtBlock3.root.position.x, dirtBlock4.root.position.x,
dirtBlock5.root.position.x, dirtBlock6.root.position.x, dirtBlock7.root.position.x, dirtBlock8.root.position.x],

[dirtBlock1.root.position.y, dirtBlock2.root.position.y, dirtBlock3.root.position.y, dirtBlock4.root.position.y,
dirtBlock5.root.position.y, dirtBlock6.root.position.y, dirtBlock7.root.position.y, dirtBlock8.root.position.y],

[dirtBlock1.root.position.z, dirtBlock2.root.position.z, dirtBlock3.root.position.z, dirtBlock4.root.position.z,
dirtBlock5.root.position.z, dirtBlock6.root.position.z, dirtBlock7.root.position.z, dirtBlock8.root.position.z],
];	  

scene.add(dirtBlock1.root); 
/**/  
/*
for(p = 0, p < landscape.length, p++) {
scene.add(landscape[p].root);
};

j = 0;

for(r = 0, r < positioning[1].length, r++) {
positioning[0][r] = j;
positioning[1][r] = j;
positioning[2][r] = 0;
j += 10
};
*/
/*
for(s = 0, s < positioning[1].length, s++) {
positioning[1][r] = j;
j += 10;
};	  
*/ 
// the a = b = c = value strategy works!

var cubeSpace = 0.5;

dirtBlock1.root.position.x = 0;
dirtBlock1.root.position.z = 0;
dirtBlock1.root.position.y = 0;

/*
dirtBlock1.root.rotation.x = 90 * degrees;
dirtBlock1.root.rotation.y = 0 * degrees;
dirtBlock1.root.rotation.z = 0 * degrees;	  
dirtBlock2.root.rotation.x = 90 * degrees;
dirtBlock2.root.rotation.y = 0 * degrees;
dirtBlock2.root.rotation.z = 0 * degrees;	

dirtBlock3.root.rotation.x = 90 * degrees;
dirtBlock3.root.rotation.y = 0 * degrees;
dirtBlock3.root.rotation.z = 0 * degrees;	

dirtBlock4.root.rotation.x = 90 * degrees;
dirtBlock4.root.rotation.y = 0 * degrees;
dirtBlock4.root.rotation.z = 0 * degrees;	

dirtBlock5.root.rotation.x = 90 * degrees;
dirtBlock5.root.rotation.y = 0 * degrees;
dirtBlock5.root.rotation.z = 0 * degrees;

dirtBlock6.root.rotation.x = 90 * degrees;
dirtBlock6.root.rotation.y = 0 * degrees;
dirtBlock6.root.rotation.z = 0 * degrees;

dirtBlock7.root.rotation.x = 90 * degrees;
dirtBlock7.root.rotation.y = 0 * degrees;
dirtBlock7.root.rotation.z = 0 * degrees;

dirtBlock8.root.rotation.x = 90 * degrees;
dirtBlock8.root.rotation.y = 0 * degrees;
dirtBlock8.root.rotation.z = 0 * degrees;	  
*/
/*
// for FPS indicatorz
stats = new Stats();
stats.domElement.style.position = 'absolute';
stats.domElement.style.top = '0px';
stats.domElement.style.zIndex = 100;
container.appendChild(stats.domElement);
// End of fps indicator
*/

/*
function abcmoves(e) {
var evtobj = window.event ? event : e //distinguish between IE's explicit event object (window.event) and Firefox's implicit.
var unicode = evtobj.charCode ? evtobj.charCode : evtobj.keyCode

// Use to make it based on alphabet characters 

var actualkey = String.fromCharCode(unicode)

//  alert(actualkey);
}
document.onkeypress = abcmoves
*/

////////////////////////////
//	  	      	    //
//  CODE FOR CHARACTER    //
//                 	    //
////////////////////////////


var metaChar = false;
var exampleKey = 16;

var leftarrow = 37;
var uparrow = 38;
var rightarrow = 39;
var downarrow = 40;
var shift = 16;
var spacebar = 32;

var a = 65;
var d = 68;
var s = 83;
var f = 70;
var l = 76;

//A = 65, a = 97, Z = 90, 0 = 48, 9 = 57

function jumpParabola() {
if(xMoverz >= 0.00001) {
bodyMovement[0].start('jump');
bodyMovement[1].start('jump');
}

speedUp = 0.000001;       
if(xMoverz < 0.00001) {
xMoverz += speedUp;	
} else {
xMoverz += 0.01;	
}

character.root.position.y = -aGraphP * (xMoverz-Math.sqrt(characterHeight/aGraphP)) * (xMoverz-Math.sqrt(characterHeight/aGraphP)) + characterHeight;
tinyboy.root.position.y = -aGraphP * (xMoverz-Math.sqrt(characterHeight/aGraphP)) * (xMoverz-Math.sqrt(characterHeight/aGraphP)) + characterHeight;

}    

function fallParabola() {
if(xMoverz >= 0.00001) {
bodyMovement[0].start('fall');
bodyMovement[1].start('fall');
}
speedUp = 0.000001;       

if(xMoverz < 0.00001) {
xMoverz += speedUp;	
} else {
xMoverz += 0.01;	
}

character.root.position.y = -aGraphP * xMoverz * xMoverz + characterHeight;
tinyboy.root.position.y = -aGraphP * xMoverz * xMoverz + characterHeight;
} 

function forwardBackwardControl(playerDirectionFacing, theSelectedKey, curSpeed, theUpArrow)
{ 
var playerDirection = "no"
var directionSign = 1;

if (theSelectedKey == theUpArrow) 
{
// move character forwards
playerDirection = 'walk';
}
else
{
// move character backwards
playerDirection = 'walkbackwards';
directionSign = -1;
}
var forwardBackwardVals = 
{
theDirection: playerDirection,
theZMove: directionSign * (Math.cos(playerDirectionFacing)) * curSpeed / 50,
theXMove: directionSign * (Math.sin(playerDirectionFacing)) * curSpeed / 50
} 
return forwardBackwardVals;
}

function leftRightControl(playerDirectionFacing, theSelectedKey, curSpeed, theLeftArrow, theDegrees)
{ 
var playerDirection = "no"
var directionSign = 1; 

if (theSelectedKey == theLeftArrow) 
{
// move character leftwards
playerDirection = 'strafeLeft';
}
else
{
// move character rightwards
playerDirection = 'strafeRight';
directionSign = -1;
}

var leftRightVals = 
{
theDirection: playerDirection,
theZMove: 1 * (Math.cos(playerDirectionFacing + directionSign * (90 * theDegrees) )) * 1 / 50,
theXMove: 1 * (Math.sin(playerDirectionFacing + directionSign * (90 * theDegrees) )) * 1 / 50
} 
return leftRightVals;
}



//    var speed = 1;
function keyEvent(event) {
//  onkeydown = onkeyup = function(event){
var key = event.keyCode || event.which;	
var keychar = String.fromCharCode(key);
// map[key] = event.type == 'keydown';

//Option 1: The mapping of keys to different key events worked, each key event worked independently 
//and they worked together. They just didn't fulfill the purpose. 


var key2 = event.keyCode || event.which;	
var keychar2 = String.fromCharCode(key2);


if (key == exampleKey) 
{
metaChar = true;
}
if (key != exampleKey) 
{
if (metaChar) 
{  metaChar = false; } 
else 
{
if (key == uparrow || key == downarrow)
{
var forBackVals = forwardBackwardControl(character.root.rotation.y, key, speed, uparrow);

bodyMovement[0].start(forBackVals.theDirection);
bodyMovement[1].start(forBackVals.theDirection);

globalVarToShow = forBackVals.theDirection;

zMove = forBackVals.theZMove;
xMove = forBackVals.theXMove;	
}

if (key == a || key == d)
{
var directionSign = 1;
if (key == a)
{
// nothing to do
}
if (key == d)
{
directionSign = -1;
}

bodyMovement[0].start('walk');
bodyMovement[1].start('walk');
yRoll = directionSign * 0.5 * speed * degrees;
}

if (key == leftarrow || key == rightarrow)
{
var leftRightVals = leftRightControl(character.root.rotation.y, key, speed, leftarrow, degrees);

bodyMovement[0].start(leftRightVals.theDirection);
bodyMovement[1].start(leftRightVals.theDirection);

globalVarToShow = leftRightVals.theDirection;

zMove = leftRightVals.theZMove;
xMove = leftRightVals.theXMove;	
}


if (key == spacebar) {
jumpParabola();
// make character jump
}	 
/*
trying to use a loop to control speed keys failed
for (i = 49, i < 57, i++) {
if (key2 == i) {
speed = (i - 48) * 2;
}
}

*/
if (key2 == 49) {
speed = (1/2) * 2;
}
else if (key2 >= 50 && key2 <=56) {
speed = (key2 - 48) * 2;
}



////////////////////////
//	  	            //
//  CODE FOR BLOCK    //
//                    //
////////////////////////


// next 3 if statements control the rotation of the cube.    

if (key == 90) { //rotation along x axis, key z
xBlockRoll = 15/50 * speed * degrees;
}

if (key == 88) {//rotation along y axis, key x
yBlockRoll = 15/50 * speed * degrees;
}

if (key == 67) { //rotation along z axis, key c
zBlockRoll = 15/50 * speed * degrees;
}




/*    
if(key == f) {
xRoll = 0.025;
if (character.root.rotation.x >= 90 * degrees) {
xRoll = 0;
}
}
if(key == s) {
character.root.rotation.x = 79 * degrees;
}
if(key == l) {
xRoll = 0.25;
}       
*/


}
}

onkeyup = function() {
if(key >= leftarrow && key <= downarrow) {
bodyMovement[0].start('stand');
bodyMovement[1].start('stand');
xMove = 0;
zMove = 0;
yRoll = 0;
// alert(characterHeight);  // works!!
}
if (key == 54) {
speed = 6*2;
}

if(key == a || key == d) {
bodyMovement[0].start('stand');
bodyMovement[1].start('stand');
yRoll = 0;
xMove = 0;
zMove = 0;

} 
/*
if(key == d) {
bodyMovement[0].start('stand');
bodyMovement[1].start('stand');
yRoll = 0;
} 
*/

/*
if(key == f) {
character.root.rotation.x = 0;
xRoll = 0;
}
if(key == s) {
character.root.rotation.x = 0;
xRoll = 0;       	
}
if(key == l) {
yMove = Math.cos(character.root.rotation.x);
zMove = Math.sin(character.root.rotation.x);
xRoll = 0;
}
*/

if (key == spacebar) {
bodyMovement[0].start('stand');
bodyMovement[1].start('stand');
/*
xGraphSqrt = 0;
speedUp = 0;
*/
xMoverz += 0;
}

if (key == 90) {
xBlockRoll = 0;
}

if (key == 88) {
yBlockRoll = 0;
}

if (key == 67) {
zBlockRoll = 0;
}


}
/*
if(key == 40){
alert(1);  // works!!
}
*/
}
onkeydown = function() {
keyEvent(event);
}
function metaKeyUp (event) {
var key = event.keyCode || event.which;
if (key == exampleKey) {
metaChar = false;
}
}


//////////////////////////////////////////////////////////////////////////////////
//		Camera Controls							//
//////////////////////////////////////////////////////////////////////////////////
var mouse = {
x: 0,
y: 0
}
document.addEventListener('mousemove', function(event) {
mouse.x = (event.clientX / window.innerWidth) - 0.5
mouse.y = (event.clientY / window.innerHeight) - 0.5
}, false)
updateFcts.push(function(delta, now) {
camera.position.x += (mouse.x*5 - camera.position.x) * (delta*3) * (4 / 100)
// camera.position.y += (mouse.y*5 - camera.position.y) * (delta*3)
// camera.lookAt makes camera focus move along with character 
//	 camera.lookAt( scene.position )
})


/////////////////////
//  Display Values //
/////////////////////

function valuedisplayer () 
{
//var testingz = ["speed: " + speed + " "]; //, "keychar: " + keychar + " ", "zMovers: " + "filler" + " "];
var sss = speed;
var hh = character.root.position.y;

var cSpeed = sss.toString();
var cVertPos = hh.toString();

var holderThis1 = globalVarToShow.toString();

//float hhhh = hh;    // doesn't work, dont know why

//var mouseXY = "mouseX: " + mouse.x + "mouseY: " + mouse.y; 
//var mouseX = mouse.x;
//var mouseY = mouse.y;

//var mX = mouseX.substring(0, 4);
//var mY = mouseY.substring(0, 4);


//var mm = testingz[0];
var speedLabel = "Speed: " + cSpeed.substring(0, 4);
var mainPlayerVerticalPos = "Main player vertical position: " + cVertPos.substring(0, 4);  /**/  
var myShowVal = "value to show: " + holderThis1;


//var mouseXYLabel = mouseXY.substring(0, 4);

document.getElementById("display1").innerHTML =  speedLabel;  // sss
document.getElementById("display2").innerHTML =  mainPlayerVerticalPos; //hhh;//
document.getElementById("display3").innerHTML = myShowVal;
//"mouseX: " + mX + " mouseY: " + mY;  //mouseXY // 
}

setInterval(valuedisplayer, 1);



//////////////////////////////////////////////////////////////////////////////////
//		render the scene						//
//////////////////////////////////////////////////////////////////////////////////
updateFcts.push(function() {
renderer.render(scene, camera);

/* 
code I added to test flexibilty of program (IT WORKS!)
*/

// camera.position.y += cheese; 

character.root.position.x += xMove;
character.root.position.y += yMove;
character.root.position.z += zMove;
character.root.rotation.x += xRoll;
character.root.rotation.y += yRoll;
character.root.rotation.z += zRoll;


tinyboy.root.position.x += xMove;
tinyboy.root.position.y += yMove;
tinyboy.root.position.z += zMove;

tinyboy.root.rotation.x += xRoll;
tinyboy.root.rotation.y += yRoll;
tinyboy.root.rotation.z += zRoll;


dirtBlock1.root.rotation.x += xBlockRoll;
dirtBlock1.root.rotation.y += yBlockRoll;
dirtBlock1.root.rotation.z += zBlockRoll;

//   character.root.rotation.z += 0.02; // this is to test the update (which works)


})

//////////////////////////////////////////////////////////////////////////////////
//		loop runner							//
//////////////////////////////////////////////////////////////////////////////////
var lastTimeMsec = null
requestAnimationFrame(function animate(nowMsec) {
// keep looping
requestAnimationFrame(animate);
// measure time
lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60
var deltaMsec = Math.min(200, nowMsec - lastTimeMsec)
lastTimeMsec = nowMsec
// call each update function
updateFcts.forEach(function(updateFn) {
updateFn(deltaMsec / 1000, nowMsec / 1000)
})
})
</script>


</body>
